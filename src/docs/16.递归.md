# 递归
递归就是方法自己调用自己，每次调用时传递不同的变量.

**递归 = 传递+回归**
- 1.传递: 明确`递归方法`的`参数`和`返回值`
- 2.回归条件: 确定`终止条件`
- 3.单层递归的逻辑





## 看图分析递归
![递归调用图](https://i.postimg.cc/zvDcXHCn/image.png)
```java
public class Ch_1_Recursion1 {
  public static void main(String[] args) {
    /**
    打印问题
      public void test(int n) {
        if (n > 2) {
          test(n-1);
        }
        System.out.println("n=" + n);
      }
      执行: test(4),输出什么?
     */  
    
    Test1 t1 = new Test1();
    
    t1.test(4); 
  }
}

class Test1 {
  public void test(int n) {
    if (n > 2) {
      test(n-1);
    }
    System.out.println("n=" + n);
  }
}
```




## 方法递归调用
- 1.执行一次方法，就会创建一个新的受保护的独立空间(栈空间)
- 2.方法的独立变量是独立的, 不会相互影响
- 3.如果方法中使用的是`引用类型`的变量(如:`数组`、`对象`), 就`会共享`该`引用类型`的数据
- 4.递归必须向退出递归的条件逼近,否则就是无限递归。会出现`StackOverflowError`
- 5.当一个方法执行完毕,或者遇到return,就会返回。遵守`谁调用`,就`将结果返回给谁`。同时当方法执行完毕或返回时,该方法也就执行完毕。






## 递归练习
```java
/**
题目:
  1.求出 斐波那契数列: 1,1,2,3,5,8,13...当n(项数) = 18时,求对应的斐波那契数是
    分析:
      n = 1, v1 = 1
      n = 2, v2 = 1
      n = 3, v3 = v2 + v1 = 2
      n = 4, v4 = v3 + v2 = 3
      n = 5, v5 = v4 + v3 = 5
      ...
      n = k(k>2), vk = v(k-1) + v(k-2)
  */

/**
题目:
  2.猴子吃桃问题:
    有一堆桃子,猴子第一天其中一半，并再多吃了一个。
    以后每天猴子都池其中的一半,并再多吃了一只。当到了第十天时(还没吃)。发现只剩下 1个桃子了。
    问: 最初一共有多少个桃子?
  分析:
    今天的桃子数 = (明天的桃子数 + 1) * 2
    k=10,v10 = 1
    k= 9,v9 = (v10 + 1) * 2 = (1 + 1) * 2 = 4
    k= 8,v8 = (v9 + 1) * 2 = (4 + 1) * 2 = 10
    k= 7,v7 = (v8 + 1) * 2 = (10 + 1) * 2 = 22
    ...
    k= 1,v1 = ?
  */
```


