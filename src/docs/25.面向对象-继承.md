# 面向对象-继承
**为何需要继承?** 
=> 解决代码的复用问题
```markdown
# 各个不同学业级别的学生考试的场景
- 学生类 - 基类
  - 成员变量: name、age、score 
  - 成员方法: testing、showInfo
    
- 大学生类 - 子类
  - extends 学生类
    
- 高中生类 - 子类
  - extends 学生类
    
- 初中生类 - 子类
  - extends 学生类
    
- 小学生类 - 子类
  - extends 学生类
```

**继承的基本语法**
```markdown
class 子类 extends 父类 {}

- 继承后，子类就能自动拥有父类定义的成员变量和成员方法、 
- 父类又叫: 超类、基类
- 子类又叫: 派生类
```



## 继承的好处:
- 1.代码的复用性提高了
- 2.代码的拓展性和维护性也提高了

**继承的细节**
- 1.`子类`会`继承`基类`所有的成员变量和方法`
  - `私有成员变量` 和 `私有成员方法`, 不能在子类直接访问。 
  - `非私有的属性和方法`都可以在子类中直接访问
  - 非私有的属性和方法 需要通过`基类提供的公共的方法`去访问
- 2.子类必须调用基类的构造器,完成基类的初始化.
- 3.当`创建子类对象`时,不管使用子类的`哪个构造器`,默认情况下都会调用基类的无参构造器。
  - 如果基类没有提供无参构造器,则必须在子类的构造器中使用`super(形参列表)`指定基类的某一个构造器 去完成基类的初始化，否则编译不通过、
- 4.`super(形参列表);` 必须放在`构造器的第一行 `
- 5.`super()` 和 `this()` 只能存在一个。 
- 6.`Object`是所有类的基类，`万物皆对象`,可以不要写出来
- 7.基类构造器的调用不限于直接父类,将一致网上追溯到`Object`类(顶级父类)<类比:js原型链>
- 8.子类最大只能继承一个父类(单继承机制)。
- 9.不能滥用继承,子类和父类之间必须满足 is-a 的逻辑关系
  - Person is Music ? false
  - Music is Person ? false
  - Cat is Animal ? true




## 继承的本质
![继承内存分析图](https://i.postimg.cc/5Nts4z4J/image.png)
- 当子类对象创建好后,与父类建立查找关系
```java
public class ExtendsTheory {
    public static void main(String[] args) {
        Son son = new Son();
    }
}
// 爷类
class GrandPa {
    String name = "大头爷爷";
    String hobby = "旅游";
}
// 父类
class Father extends GrandPa {
    String name = "大头爸爸";
    int age = 39;
}
// 子类
class Son extends Father {
    String name = "大头儿子";
}
```

**查找规则**
- 1.先查看子类是否有这个属性
- 2.如果子类有这个属性, 并且可以访问，则返回信息
- 3.如果子类没有,就找父类有没有这个属性(如果父类有该属性,并且可以访问,就返回信息)
- 4.如果父类没有，则继续按照(规则3)继续找上级父类,直到`Object类`。

注意: 如果在查找的过程中，查找被堵住了(有属性但不能访问。不会跳过这层往上级父类继续找的),是直接编译报错了。
解决被堵住报错: 
- 让私有属性的类提供可以访问该私有属性的公开方法
- 使用多态
